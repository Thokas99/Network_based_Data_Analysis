---
title: "ADA_project_final"
author: "Thomas Sirchi"
format: html
editor: visual
---
## Loading packages

Store package names in a vectors for ease of access and to load them easily

```{r setup, message=FALSE, warning=FALSE}
# List of R packages used in the script with a brief description of their purposes
PACKAGES <- c(
  "GEOquery",        # For accessing and retrieving Gene Expression Omnibus (GEO) data
  "limma",           # For linear modeling of microarray data and differential expression analysis
  "plotly",          # Interactive plotting library for creating dynamic and interactive visualizations
  "RColorBrewer",    # Color palettes for enhancing the visual appeal of plots and charts
  "factoextra",      # Provides additional functions for enhanced ggplot-based plots in multivariate analysis
  "FactoMineR",      # For multivariate exploratory data analysis, including PCA and clustering
  "cluster",         # To perform PAM (Partitioning Around Medoids) and other clustering methods
  "glmnet",          # To perform LASSO (Least Absolute Shrinkage and Selection Operator) regression for feature selection
  "biomaRt",         # Interface to access and query BioMart databases for biological annotations
  "enrichR",         # For gene set enrichment analysis to identify enriched biological pathways
  "rScudo",          # To perform SCUDO (Signature-based Clustering for Diagnostic Purposes) for classification
  "EnhancedVolcano", # For volcano plots with enhanced features for visualizing differential expression results
  "umap",            # For dimensionality reduction and visualization using Uniform Manifold Approximation and Projection
  "gprofiler2",      # Tools for functional enrichment analysis and gene set analysis
  "caret",           # Comprehensive machine learning toolkit for classification and regression training
  "randomForest",
  "tidyverse"
)



invisible(lapply(PACKAGES, library, character.only = TRUE))
gc()
# Install packages (uncomment the line below to install)
# install.packages(PACKAGES)
```


Print current system info, R and packages versions (for reproducibility)

```{r sessionInfo}
sessionInfo()
```

## Data retrieval

Retrieve dataset from GEO

```{r Retrieve dataset from GEO, message=FALSE, warning=FALSE}
#gset2 <- getGEO("GSE15235", GSEMatrix =TRUE,destdir = ".")

# Extract the data
exp_data <- data.frame(gset2[["GSE15235_series_matrix.txt.gz"]]@assayData[["exprs"]])
exp_data <- na.omit(exp_data)
head(exp_data)
```

# Metatdata manipulation

recover the gene ids and disease state from the metadata.

```{r Metadata extraction}
# general metatdata on the disease
metadata <- data.frame(gset2[["GSE15235_series_matrix.txt.gz"]]@phenoData@data)
metadata <- metadata %>% 
  dplyr::rename(molecular_group = molecular.group.ch1)
#write.csv(metadata, file = 'metadata1.csv', row.names = TRUE)

disease_state <- subset(metadata, select = molecular_group)

# general metatdata on the Affimatrix, experiment, gene symbol etc. 
metadata2 <- data.frame(gset2[["GSE15235_series_matrix.txt.gz"]]@featureData@data)
#write.csv(metadata2, file = 'metadata2.csv', row.names = TRUE)

# retrive more metadata
metadata3 <- read.csv("tabula-gm154-S3.csv")

metadata3 <- metadata3 %>%
  slice(-1) %>%
  slice(-1) %>%
  dplyr::select(-c("CB","X","Weight.Z")) %>%
  mutate_all(~ifelse(. == "N/A", "Unknown", .))
Clinical <- read.csv("Clinical.csv")

metadata <- metadata %>%
  bind_cols(metadata3) %>%
  bind_cols(Clinical) %>%
  mutate(
    Age = as.numeric(Age),
    Alive.or.transplant = ifelse(Alive.or.transplant != "Alive", "transplant", Alive.or.transplant)
  )

head(metadata)
head(metadata2)
rm(metadata3,Clinical)
```


```{r Gene name conversion}
Gene_Symbols <- gprofiler2::gconvert(query = metadata2$ID, 
                                   organism = "hsapiens",
                                   numeric_ns = "AFFY_HG_U133_PLUS_2",
                                   target="ARRAYEXPRESS", 
                                   mthreshold = Inf, 
                                   filter_na = TRUE)

Gene_Symbols <- Gene_Symbols %>%
  dplyr::distinct(input, .keep_all = TRUE) %>% # Keep only unique IDs while retaining all columns
  dplyr::mutate(probe_id = input ) %>%
  dplyr::select(probe_id, target, name, description) %>% # Select specified columns
  dplyr::filter(name != "none")
  
head(Gene_Symbols)
```

```{r}
# Boxplot
ggplot(metadata, aes(x = molecular_group, y = Age, fill = molecular_group)) +
  geom_boxplot() +
  xlab("Molecular Group") +
  ylab("Age (days)") +
  ggtitle("Distribution of Age by Molecular Group")

# Line plot of age distribution for each subtype
ggplot(metadata, aes(x = Age, color = molecular_group)) +
  geom_density() +
  xlab("Age (days)") +
  ylab("Density") +
  ggtitle("Distribution of Age by Molecular Group")
```

# FIRST FILTER BY GENE NAMES

```{r Data Preprocessing: center the log data, warning=FALSE}
#data_recipe <- recipe(~ ., data = exp_data) %>%
  # Log transform and center numeric variables
  #step_scale(all_numeric()) %>%
  #step_log(all_numeric()) %>%
  #step_center(all_numeric())

# Preprocess data
#data_preprocessed <- prep(data_recipe, data = exp_data)

# Transform the data
#temp_data <- data.frame(bake(data_preprocessed, new_data = NULL))
#rownames(temp_data) <- rownames(exp_data)

# traspose the 
t_data <- (t(exp_data))

t_data <- cbind(t_data, disease_state)

t_data <- t_data %>%
  dplyr::select(Gene_Symbols$probe_id)

t_data <- cbind(t_data, disease_state)
head(t_data)
# FIRST FILTER BY GENE NAMES


```

The dataset has alredy been scaled by the authors, let's check with a boxplot

```{r v, message=FALSE, warning=FALSE}
# Select the first 2000 genes
subset_data <- (exp_data)#[1:5000,]

# Melt the transposed data
melted_data <- reshape2::melt(subset_data)

# Create boxplot with only the first 2000 genes
ggplot(melted_data, aes(x = Var2, y = value, fill = Var2)) +
  geom_boxplot(alpha = 0.2) +  # Set alpha for transparency
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1, size = 8),  # Adjust x-axis text appearance
        axis.text.y = element_text(size = 8),  # Adjust y-axis text appearance
        legend.position = "none") +  # Remove legend
  labs(x = "Samples", y = "Expression Value",  # Set axis labels
       title = "Boxplot of dataset",  # Set plot title
       subtitle = "Distribution of gene expression values across samples") +  # Add subtitle
  theme(plot.title = element_text(size = 14, face = "bold"),  # Adjust title appearance
        plot.subtitle = element_text(size = 12))  # Adjust subtitle appearance

rm(subset_data,melted_data)
```

## Unsupervised methods (machine learning methods)
#PCA

```{r Principal component analysis PCA, message=FALSE, warning=FALSE}

# Perform Principal Component Analysis (PCA) on the transpose of the cleaned data
res_pca <- prcomp(t_data[,-ncol(t_data)])

# Extract eigenvalues and variance contributions from the PCA results
eig_PCA <- get_eig(res_pca)

# Transform the principal components into a data frame
components <- res_pca[["x"]]
components <- data.frame(components)

# Combine the principal components with the original disease_state metadata
components <- cbind(components, disease_state)

#Scree plot
# Plotting eigenvalues
fviz_eig(res_pca, addlabels = TRUE, barcolor = "skyblue",
         barfill = "skyblue", pointsize = 5, main = "Scree Plot of PCA",
         xlab = "Principal Component", ylab = "Eigenvalue")


# Remove unnecessary objects
rm(eig_PCA,res_pca)

```

```{r Plot PCA, message=FALSE, warning=FALSE}

# Create a 2D scatter plot using Plotly
fig2D <- plot_ly(components, 
                 x = ~PC1, y = ~PC2, #z = ~PC3,
                 color = disease_state$molecular_group,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 #type = "scatter",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE) %>%
  layout(title = "PCA Plot",
         xaxis = list(title = "PCA 1"),
         yaxis = list(title = "PCA 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the 2D scatter plot
fig2D

# Remove the 2D scatter plot object to free up memory
rm(fig2D)

```

# Uniform Manifold Approximation and Projection (UMAP)

```{r UMAP}
set.seed(1234)
# Perform UMAP dimensionality reduction
umap_result <- umap(
  t_data[, -ncol(t_data)],     # Input data: Exclude the last column
  n_neighbors = 15,            # Number of neighboring data points to consider
  metric = "euclidean",        # Distance metric to use
  n_components = 2,            # Number of components in the reduced space
  min_dist = 0.1,              # Minimum distance between points in the embedding
  spread = 1.0,                # Spread of the low-dimensional representation
  set_op_mix_ratio = 1.0,      # Mix ratio for set operation
  local_connectivity = 1.0,    # Connectivity parameter for local UMAP
  repulsion_strength = 1.0,    # Strength of the repulsion forces
)


umap_df <- data.frame(umap_result$layout)
colnames(umap_df) <- c("umap_1","umap_2")# ,"umap_3"
rownames(umap_df) <-  rownames(t_data) 
# Print UMAP
print(umap_result)

umap_df <- cbind(umap_df,disease_state)
# Create a 2D scatter plot using Plotly
# Create the plot
fig2D <- plot_ly(umap_df, 
                 x = ~umap_1, y = ~umap_2,#z = ~umap_3,
                 color = umap_df$molecular_group,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 #type = "scatter3d",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "UMAP Plot",
         xaxis = list(title = "UMAP 1"),
         yaxis = list(title = "UMAP 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the plot
fig2D
# Remove the 2D scatter plot object to free up memory
rm(fig2D,umap_result)
```

# PAM (Partitioning Around Medoids)

```{r Find best K , message=FALSE, warning=FALSE}
set.seed(1234)

# Visualize the optimal number of clusters using the elbow method
fviz_nbclust(t_data[,-ncol(t_data)], FUNcluster = pam, method = "wss", k.max = 5)
fviz_nbclust(t_data[,-ncol(t_data)], FUNcluster = pam, method = "silhouette", k.max = 5)
#fviz_nbclust(t(exp_data), FUNcluster = pam, method = "gap_stat", k.max = 5)
```

```{r Compute PAM , message=FALSE, warning=FALSE}
set.seed(1234)
K <- 2
# Perform PAM clustering
pam_result <- pam(t_data[,-ncol(t_data)], K,trace.lev = 2,pamonce = 6)

# Access cluster assignments and medoids
cluster_assignments <- pam_result$clustering

cluster_assignments <- ifelse(cluster_assignments == 1, "Group_1", 
                         ifelse(cluster_assignments == 2, "Group_2", cluster_assignments))

umap_df$cluster_assignments <- as.character(cluster_assignments)

medoids <- pam_result$medoids

# Display a table of cluster assignments and disease states
table(cluster_assignments, t(disease_state))

# Store cluster assignments in components$pam
#components <- cbind(components, cluster_assignments)
cluster_assignments <- data.frame(cluster_assignments)
rownames(cluster_assignments) <- rownames(t_data)

fig2D <- plot_ly(umap_df, 
                 x = ~umap_1, y = ~umap_2,#z = ~umap_3,
                 color = umap_df$cluster_assignments,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "UMAP Plot",
         xaxis = list(title = "UMAP 1"),
         yaxis = list(title = "UMAP 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the plot
fig2D

# Remove unnecessary objects
rm(pam_result,K,medoids,fig2D)


```

# hierarchical clustering

```{r hierarchical, message=FALSE, warning=FALSE}
# Calculate distances and create a dendrogram
dm <- dist(t_data[,-ncol(t_data)])
#Ward’s Method: Minimizes the increase in variance when merging clusters. It aims to create compact, balanced clusters by considering within-cluster variance.
hc <- hclust(dm, method = "complete")
plot(hc, hang = -1)
rect.hclust(hc, k = 2, border = 'lightcoral')

# Assign cluster memberships
clust.vec.2 <- cutree(hc, k = 2)
# Visualize clusters
fviz_cluster(list(data = t(exp_data), cluster = clust.vec.2))

umap_df$hclust <- clust.vec.2

# Remove unnecessary objects
#rm(dm, hc,clust.vec.2)

```

# Two groups probelm, diving deeper

```{r Run the degs Group_1 - Group_2}
set.seed(1234)

# Create a design matrix without an intercept for two groups
design <- model.matrix(~ 0 + umap_df$cluster_assignments)
colnames(design) <- c("Group_1","Group_2")

# Fit a linear model to the log-transformed data
fit <- lmFit(t(t_data[,-ncol(t_data)]), design)

# Specify contrasts of interest between Fibrosis and Inflammation
contrast.matrix <- makeContrasts(Group_1 - Group_2, levels = design)

# Apply empirical Bayes moderation to the linear model fit
fit <- eBayes(fit,robust = T)

# Extract the top differentially expressed genes based on the specified contrast
de.genes <- topTable(fit, coef = 1,p.value = 0.01, sort.by = "logFC", number=Inf,adjust="BH")
de.genes2 <- topTable(fit, coef = 2,p.value = 0.01, sort.by = "logFC",number=Inf,adjust="BH")

# Assuming de.genes is your data frame with the differential expression results
volcano_plot_1 <- EnhancedVolcano(de.genes,
                                lab = rownames(de.genes),
                                x = 'logFC',
                                y = 'P.Value',
                                title = 'Volcano plot of 1 DEGs',
                                pCutoff = 0.001,
                                FCcutoff = 1.5,
                                pointSize = 2.0,
                                labSize = 4.0,
                                legendLabSize = 10,
                                legendIconSize = 3.0,
                                drawConnectors = F,
                                widthConnectors = 0.5)

print(volcano_plot_1)


# Assuming de.genes is your data frame with the differential expression results
volcano_plot_2 <- EnhancedVolcano(de.genes2,
                                lab = rownames(de.genes2),
                                x = 'logFC',
                                y = 'P.Value',
                                title = 'Volcano plot of 2 DEGs',
                                pCutoff = 0.001,
                                FCcutoff = 1.5,
                                pointSize = 2.0,
                                labSize = 4.0,
                                legendLabSize = 10,
                                legendIconSize = 3.0,
                                drawConnectors = F,
                                widthConnectors = 0.5)

print(volcano_plot_2)

rm(fit,design,contrast.matrix,volcano_plot_2,volcano_plot_1)
```

```{r Filter the XIST}
#filt <- head(de.genes, 6) %>%
  #dplyr::mutate(probe_id = rownames(.))

#filt <- filt %>%
  #left_join(Gene_Symbols, filt, by = "probe_id") 

#write.csv(filt,"XIST_probes_to_DEL.csv")
filt <- read.csv("XIST_probes_to_DEL.csv")
filt

t_data <- t_data %>%
  dplyr::select(-filt$probe_id)

rm(filt)
#rm(de.genes,de.genes2,filt)
```

```{r Principal component analysis PCA, message=FALSE, warning=FALSE}

# Perform Principal Component Analysis (PCA) on the transpose of the cleaned data
res_pca <- prcomp(t_data[,-ncol(t_data)])

# Extract eigenvalues and variance contributions from the PCA results
eig_PCA <- get_eig(res_pca)

# Transform the principal components into a data frame
components <- res_pca[["x"]]
components <- data.frame(components)

# Combine the principal components with the original disease_state metadata
components <- cbind(components, disease_state)

#Scree plot
# Plotting eigenvalues
fviz_eig(res_pca, addlabels = TRUE, barcolor = "skyblue",
         barfill = "skyblue", pointsize = 5, main = "Scree Plot of PCA",
         xlab = "Principal Component", ylab = "Eigenvalue")

# Trigger garbage collection to free up memory
gc()

# Remove unnecessary objects
rm(eig_PCA,res_pca)

```

```{r Plot PCA, message=FALSE, warning=FALSE}

# Create a 2D scatter plot using Plotly
fig2D <- plot_ly(components, 
                 x = ~PC1, y = ~PC2, #z = ~PC3,
                 color = disease_state$molecular_group,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "PCA Plot",
         xaxis = list(title = "PCA 1"),
         yaxis = list(title = "PCA 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the 2D scatter plot
fig2D

# Remove the 2D scatter plot object to free up memory
rm(fig2D)

```

# 2. Uniform Manifold Approximation and Projection (UMAP)

```{r UMAP 2 }
set.seed(1234)

# Perform UMAP dimensionality reduction
umap_result <- umap(
  t_data[, -ncol(t_data)],     # Input data: Exclude the last column
  n_neighbors = 7,            # Number of neighboring data points to consider
  metric = "euclidean",        # Distance metric to use
  n_components = 2,            # Number of components in the reduced space
  min_dist = 0.1,              # Minimum distance between points in the embedding
)

umap_df <- data.frame(umap_result$layout)
colnames(umap_df) <- c("umap_1","umap_2")# ,"umap_3"
rownames(umap_df) <-  rownames(t_data) 
# Print UMAP
print(umap_result)

umap_df <- cbind(umap_df,disease_state)
# Create a 2D scatter plot using Plotly
# Create the plot
fig2D <- plot_ly(umap_df, 
                 x = ~umap_1, y = ~umap_2,#z = ~umap_3,
                 color = umap_df$molecular_group,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 #type = "scatter3d",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "UMAP Plot",
         xaxis = list(title = "UMAP 1"),
         yaxis = list(title = "UMAP 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the plot
fig2D
# Remove the 2D scatter plot object to free up memory
rm(fig2D,umap_result)
```

# 2. PAM (Partitioning Around Medoids)

```{r Find best K , message=FALSE, warning=FALSE}
set.seed(1234)

# Visualize the optimal number of clusters using the elbow method
#fviz_nbclust(t_data[,-ncol(t_data)], FUNcluster = pam, method = "wss", k.max = 5)
fviz_nbclust(t_data[,-ncol(t_data)], FUNcluster = pam, method = "silhouette", k.max = 5)
fviz_nbclust(t(exp_data), FUNcluster = pam, method = "gap_stat", k.max = 5,print.summary = T,nboot = 5)
```

```{r Compute PAM , message=FALSE, warning=FALSE}
set.seed(1234)
K <- 2
# Perform PAM clustering
pam_result <- pam(t_data[,-ncol(t_data)], K,trace.lev = 2,variant = "o_2")

# Access cluster assignments and medoids
cluster_assignments <- pam_result$clustering

cluster_assignments <- ifelse(cluster_assignments == 1, "Group_1", 
                         ifelse(cluster_assignments == 2, "Group_2", cluster_assignments))

umap_df$cluster_assignments <- as.character(cluster_assignments)

medoids <- pam_result$medoids

# Display a table of cluster assignments and disease states
table(cluster_assignments, t(disease_state))

# Store cluster assignments in components$pam
#components <- cbind(components, cluster_assignments)
cluster_assignments <- data.frame(cluster_assignments)
rownames(cluster_assignments) <- rownames(t_data)

fig2D <- plot_ly(umap_df, 
                 x = ~umap_1, y = ~umap_2,#z = ~umap_3,
                 color = umap_df$cluster_assignments,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "UMAP Plot",
         xaxis = list(title = "UMAP 1"),
         yaxis = list(title = "UMAP 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the plot
fig2D

# Remove unnecessary objects
rm(pam_result,K,medoids,fig2D)
```

# 2. hierarchical clustering

```{r hierarchical, message=FALSE, warning=FALSE}
# Calculate distances and create a dendrogram
dm <- dist(t_data[,-ncol(t_data)])
#Ward’s Method: Minimizes the increase in variance when merging clusters. It aims to create compact, balanced clusters by considering within-cluster variance.
hc <- hclust(dm, method = "complete")
plot(hc, hang = -1)
rect.hclust(hc, k = 2, border = 'lightcoral')

# Assign cluster memberships
clust.vec.2 <- cutree(hc, k = 2)
# Visualize clusters
fviz_cluster(list(data = t(exp_data), cluster = clust.vec.2))

umap_df$hclust <- clust.vec.2

# Remove unnecessary objects
rm(dm, hc,clust.vec.2)
```

# Supervised learning techniques

```{r}
# Set seed for reproducibility
set.seed(1234)

# Filter out 'Unclassified' data
ML_data <- subset(t_data, molecular_group != "Unclassified")

# Store 'Unclassified' data separately
Unclassified <- subset(t_data, molecular_group == "Unclassified")

# Create training and testing indices
trainIndex <- createDataPartition(ML_data$molecular_group, p = 0.7, list = FALSE)

# Create training data
trainData <- ML_data[trainIndex, ]

# Convert the target variable to a factor and remove it from the training data
trainData_l <- as.factor(trainData$molecular_group)
trainData$molecular_group <- NULL

# Apply ADASYN transformation to the training data
#trainData <- ADAS(trainData, target = trainData_l)

# Convert the target variable to a factor and remove it from the training data again 
#trainData_l <- as.factor(trainData$class)
#trainData$class <- NULL

# Extract the transformed data from the ADASYN object
#trainData <- trainData$data

# Create testing data
testData <- ML_data[-trainIndex, ]

# Convert the target variable to a factor and remove it from the testing data
testData_l <- as.factor(testData$molecular_group)
testData$molecular_group <- NULL


```

# Set up parallel backend
```{r Create parallel cluster}
cl <- parallel::makePSOCKcluster(5)
doParallel::registerDoParallel(cl)
```

# RANDOM FOREST

```{r tune mtry}
set.seed(1234)
tuned_rf <- tuneRF(x = trainData, 
                     y = trainData_l, 
                     ntreeTry = 200, 
                     stepFactor = 2, 
                     improve = 0.01, 
                     mtryStart = 214, 
                     trace = TRUE, 
                     plot = TRUE,
                  )
# Print the best mtry values
print(tuned_rf)
```


```{r Run the forest}
set.seed(1234)
# Define the training control
ctrl <- trainControl(method = "repeatedcv", 
                     number = 2,
                     repeats = 2,
                     savePredictions = "final",
                     #sampling = "smote",
                     allowParallel = T)

param_grid <- expand.grid(mtry = c(27),
                          splitrule = c("gini"),
                          min.node.size = c(1,8,3,4))

# Train the ranger model with cross-validation
set.seed(123)  # for reproducibility
model <- train(y = trainData_l, 
               x = trainData, 
               method = "ranger",
               num.trees=200,
               importance = "permutation", #impurity permutation
               num.threads = 5,
               trControl = ctrl,
               tuneGrid = param_grid
               )

# Print the model
print(model)
plot(model)

# Summarize results
print(model$results)

fitted_ranger <- model$finalModel

predictions <- predict(fitted_ranger, testData)
# print CM
cm <- confusionMatrix(predictions$predictions, testData_l, mode = "everything")
cm

metrics_RF <- data.frame(metrics = c(cm[["overall"]], cm[["byClass"]][["F1"]]))
rownames(metrics_RF) <- c("Accuracy", "Kappa", "AccuracyLower", "AccuracyUpper", "AccuracyNull", "AccuracyPValue", "McnemarPValue", "F1")
write.csv(metrics_RF,"metrics_RF.csv", row.names = T)

# Get confusion matrix data
conf_matrix_data <- as.data.frame(as.table(cm$table))

# Plot confusion matrix using ggplot2
ggplot(conf_matrix_data, aes(x = Prediction, y = Reference, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = sprintf("%d", Freq)), vjust = 0.5) +
  scale_fill_gradient(low = "white", high = "lightcoral") +
  theme_minimal() +
  labs(x = "Predicted", y = "Actual", fill = "Frequency", title = "Confusion Matrix")+
  theme(legend.position = "none")

RF_var_importance3 <- 
  data.frame(importance = ranger::importance(fitted_ranger)) %>%
  dplyr::mutate(probe_id = rownames(.)) %>%
  dplyr::arrange(desc(importance)) 

RF_var_importance3 <- dplyr::left_join(RF_var_importance3, Gene_Symbols, by = "probe_id") %>%
  na.omit() %>%
  dplyr::distinct(name, .keep_all = TRUE)

high_threshold <- max(RF_var_importance3$importance) * 0.60
medium_threshold <- max(RF_var_importance3$importance) * 0.50

# Categorize values
RF_var_importance3$Category <- cut(RF_var_importance3$importance,
                     breaks = c(0, medium_threshold, high_threshold, Inf),
                     labels = c("Low", "Medium", "High"))

RF_var_importance3 <- subset(RF_var_importance3, name != "None")

# Create the plot
ggplot(head(RF_var_importance3, 25), aes(x = importance, y = reorder(name, importance), fill = Category)) +
  geom_bar(stat = "identity") +
  scale_fill_manual(values = c("lightcoral", "lightgreen", "skyblue")) +  # Choose colors for each category
  labs(title = "Top 25 Variable Importance Plot RF", x = "Importance", y = "Variable") +
  guides(fill = guide_legend(reverse = TRUE))

RF_results3 <- data.frame(predict(fitted_ranger, data = Unclassified[,-ncol(Unclassified)]))
rownames(RF_results3) <- rownames(Unclassified)

RF_results3
head(RF_var_importance3)

#rm(ctrl, param_grid, model, predictions, cm, conf_matrix_data, high_threshold, medium_threshold)
```

# Feature selection with LASSO (Least Absolute Shrinkage and Selection Operator)
```{r Tuning LASSO}
set.seed(1234)

# Perform cross-validation for Lasso regression
cv_lasso <- cv.glmnet(
  x = as.matrix(trainData),  # Predictor matrix
  y = as.numeric(trainData_l),  # Response variable
  family = "binomial",  # Gaussian family for regression
  alpha = 0.2,  # Lasso penalty parameter (0 for ridge, 1 for Lasso)
  grouped = FALSE,  # Indicate whether variables are grouped
  parallel = TRUE,  # Use parallel computation if available
  nlambda = 500,  # Number of lambda values to use
  relax = TRUE,  # Relax convergence criterion
  type.measure = "mse",  # Type of performance measure (Mean Squared Error)
  nfolds = 3,  # Number of cross-validation folds
  trace.it = 1
)

plot(cv_lasso)

print(cv_lasso)
optimal_lambda <- cv_lasso$lambda.min

# Remove unnecessary objects
#rm(cv_lasso)
```

```{r Fit LASSO}
set.seed(1234)


# Fit a lasso regression model
lasso_model <- glmnet(x = as.matrix(trainData),  # Predictor matrix
                      y = as.numeric(trainData_l),  # Response variable
                      alpha = 0.2, 
                      lambda = optimal_lambda,
                      family = "binomial",
                      parallel = TRUE,
                      type.measure = "mse",
                      relax = TRUE,
                      trace.it = 1)

# Display selected features
print(lasso_model)
plot(coef(lasso_model, s = optimal_lambda))
# Add title
title("Lasso Coefficients")

to_filter <- names(lasso_model$beta[, 1][lasso_model$beta[, 1] != 0])
names_imp <- data.frame(lasso_model$beta[, 1][lasso_model$beta[, 1] != 0])
# Extract non-zero coefficients from the Lasso model
selected_features <- coef(lasso_model, s = optimal_lambda, exact = TRUE, x = X, y = y)

# Filter the original dataset based on selected features
df_filtered <- subset(t_data, select = to_filter)

df_filtered <- cbind(df_filtered, disease_state)

predictions_LASSO <-data.frame(predict(lasso_model, as.matrix(testData),type="class"))

# print CM
cm <- confusionMatrix(as.factor(predictions_LASSO$s0), as.factor(as.numeric(testData_l)), mode = "everything")
cm

metrics_LASSO <- data.frame(metrics = c(cm[["overall"]], cm[["byClass"]][["F1"]]))
rownames(metrics_LASSO) <- c("Accuracy", "Kappa", "AccuracyLower", "AccuracyUpper", "AccuracyNull", "AccuracyPValue", "McnemarPValue", "F1")
write.csv(metrics_LASSO,"metrics_LASSO.csv", row.names = T)
# Get confusion matrix data
conf_matrix_data <- as.data.frame(as.table(cm$table))

# Plot confusion matrix using ggplot2
ggplot(conf_matrix_data, aes(x = Prediction, y = Reference, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = sprintf("%d", Freq)), vjust = 0.5) +
  scale_fill_gradient(low = "white", high = "lightcoral") +
  theme_minimal() +
  labs(x = "Predicted", y = "Actual", fill = "Frequency", title = "Confusion Matrix")+
  theme(legend.position = "none")

predictions_LASSO <-data.frame(predict(lasso_model, as.matrix(Unclassified[,-ncol(Unclassified)]),type="class"))

# Replace values based on condition
predictions_LASSO$s0 <- ifelse(predictions_LASSO$s0 == 1, "Fibrosis", 
                         ifelse(predictions_LASSO$s0 == 2, "Inflammation", predictions_LASSO$s0))

# Print the updated data frame
predictions_LASSO
```

```{r KNN}

set.seed(1234)
# Define the training control
ctrl <- trainControl(method = "repeatedcv", 
                     number = 2,
                     repeats = 2,
                     savePredictions = "final",
                     #sampling = "smote",
                     allowParallel = T
                    )

param_grid <- expand.grid(k = 7:8)

# Train the ranger model with cross-validation
set.seed(123)  # for reproducibility
model_knn <- train(y = trainData_l, 
               x = trainData, 
               method = "knn",
               tuneGrid = param_grid,
               trControl = ctrl
                           )

# Print the model_knn
summary(model_knn)
print(model_knn)
plot(model_knn)

# Summarize results
print(model_knn$results)

fitted_knn <- model_knn$finalModel

predictions <- predict(model_knn, testData)
# print CM
cm <- confusionMatrix(predictions, testData_l, mode = "everything")
cm

metrics_KNN <- data.frame(metrics = c(cm[["overall"]], cm[["byClass"]][["F1"]]))
rownames(metrics_KNN) <- c("Accuracy", "Kappa", "AccuracyLower", "AccuracyUpper", "AccuracyNull", "AccuracyPValue", "McnemarPValue", "F1")
write.csv(metrics_KNN,"metrics_KNN.csv", row.names = T)

# Get confusion matrix data
conf_matrix_data <- as.data.frame(as.table(cm$table))

# Plot confusion matrix using ggplot2
ggplot(conf_matrix_data, aes(x = Prediction, y = Reference, fill = Freq)) +
  geom_tile() +
  geom_text(aes(label = sprintf("%d", Freq)), vjust = 0.5) +
  scale_fill_gradient(low = "white", high = "lightcoral") +
  theme_minimal() +
  labs(x = "Predicted", y = "Actual", fill = "Frequency", title = "Confusion Matrix")+
  theme(legend.position = "none")

knn_results3 <- data.frame(predictions = predict(model_knn, newdata = Unclassified))
rownames(knn_results3) <- rownames(Unclassified)

knn_results3
```


# Stop cluster
```{r Stop parallel}
parallel::stopCluster(cl)
rm(cl)
```

# New lables
```{r}
disease_state[(nrow(disease_state)-3):nrow(disease_state),] <- RF_results3
disease_state$molecular_group <- ifelse(disease_state$molecular_group == 1, "Fibrosis", 
                         ifelse(disease_state$molecular_group == 2, "Inflammation", disease_state$molecular_group))
```



# DEGS with limma

```{r}
set.seed(1234)

fig2D <- plot_ly(umap_df, 
                 x = ~umap_1, y = ~umap_2,#z = ~umap_3,
                 color = disease_state$molecular_group,
                 colors = brewer.pal(n = 4, name = "RdBu"),  
                 mode = 'markers',
                 type = "scatter",
                 marker = list(size = 10, opacity = 0.8),
                 showlegend = TRUE,
                 text = metadata$geo_accession) %>%
  layout(title = "UMAP Plot",
         xaxis = list(title = "UMAP 1"),
         yaxis = list(title = "UMAP 2"),
         legend = list(title = "Molecular Group"),
         hovermode = "closest")

# Display the plot
fig2D
# Create a design matrix without an intercept for two groups
design <- model.matrix(~ 0 + disease_state$molecular_group)
colnames(design) <- c("Fibrosis","Inflammation")

# Fit a linear model to the log-transformed data
fit <- lmFit(t(t_data[,-ncol(t_data)]), design)

# Specify contrasts of interest between Fibrosis and Inflammation
contrast.matrix <- makeContrasts(Fibrosis - Inflammation, levels = design)

# Apply empirical Bayes moderation to the linear model fit
fit <- eBayes(fit,robust = T)

# Extract the top differentially expressed genes based on the specified contrast
de.genes <- topTable(fit, coef = 1,p.value = 0.001, sort.by = "logFC", number=Inf,adjust="BH")
de.genes2 <- topTable(fit, coef = 2,p.value = 0.001,sort.by = "logFC",number=Inf,adjust="BH")

# Assuming de.genes is your data frame with the differential expression results
volcano_plot_Fibrosis <- EnhancedVolcano(de.genes,
                                lab = rownames(de.genes),
                                x = 'logFC',
                                y = 'P.Value',
                                title = 'Volcano plot of Fibrosis DEGs',
                                pCutoff = 0.0001,
                                FCcutoff = 1.5,
                                pointSize = 2.0,
                                labSize = 4.0,
                                legendLabSize = 10,
                                legendIconSize = 3.0,
                                drawConnectors = F,
                                widthConnectors = 0.5)

print(volcano_plot_Fibrosis)


# Assuming de.genes is your data frame with the differential expression results
volcano_plot_Inflammation <- EnhancedVolcano(de.genes2,
                                lab = rownames(de.genes2),
                                x = 'logFC',
                                y = 'P.Value',
                                title = 'Volcano plot of Inflammation DEGs',
                                pCutoff = 0.0001,
                                FCcutoff = 1.5,
                                pointSize = 2.0,
                                labSize = 4.0,
                                legendLabSize = 10,
                                legendIconSize = 3.0,
                                drawConnectors = F,
                                widthConnectors = 0.5)

print(volcano_plot_Inflammation)

rm(volcano_plot_Fibrosis,volcano_plot_Inflammation,fit,design,contrast.matrix)

```



```{r DEGs results}

filtered_Fibrosis <- de.genes %>%
  dplyr::select(logFC, P.Value) %>%
  mutate(probe_id = rownames(de.genes)) %>%
  filter(logFC > 1.5 | logFC < -1.5 & P.Value < 0.000001)  %>%
  #arrange(-logFC)
  arrange(P.Value) 
rownames(filtered_Fibrosis) <- filtered_Fibrosis$probe_id

filtered_Inflammation <- de.genes2 %>%
  dplyr::select(logFC, P.Value) %>%
  mutate(probe_id = rownames(de.genes2)) %>%
  filter(logFC > 1.5 | logFC < -1.5 & P.Value < 0.000001)  %>%
  #arrange(-logFC)
  arrange(P.Value)
rownames(filtered_Inflammation) <- filtered_Inflammation$probe_id
# Found gene name
filtered_Fibrosis <- filtered_Fibrosis %>% 
  inner_join(Gene_Symbols, by = "probe_id")%>%
  dplyr::distinct(name, .keep_all = TRUE)

filtered_Inflammation <- filtered_Inflammation %>% 
  inner_join(Gene_Symbols, by = "probe_id")%>%
  dplyr::distinct(name, .keep_all = TRUE)

write.csv(na.omit(filtered_Inflammation$name), file = 'DEG_to_STRING.csv', row.names = F)
write.csv(na.omit(filtered_Fibrosis$name), file = 'DEG_to_STRING_F.csv', row.names = F)


#rm(de.genes,de.genes2)
```

# Unite RF and DEGs

```{r DEGs importance in RF}

filtered_df_RF <- left_join(RF_var_importance3, filtered_Inflammation, by = "probe_id") %>%
  dplyr::select(-c("target.y","name.y","description.y")) %>%
  na.omit(.) %>%
  dplyr::select(-Category)
rownames(filtered_df_RF) <- filtered_df_RF$name.x

filtered_df_RF
write.csv(filtered_df_RF,"filtered_Inflammation_RF_DEGs.csv")

```


# Pheatmap

```{r}

heat_data <- t_data %>%
  dplyr::select(filtered_df_RF$probe_id,molecular_group) %>%
  mutate(molecular_group = disease_state$molecular_group) %>%
  arrange(molecular_group)
  

# Biliary atresia with splenic malformation syndrome (BASM) designates the association of biliary atresia (see this term) and splenic abnormalities (mainly polysplenia and less frequently asplenia, double spleen)

# Biliary atresia is an obstructive cholangiopathy of unknown etiology involving both the intrahepatic and extrahepatic bile ducts
library("pheatmap")
pheatmap(heat_data[,-ncol(heat_data)], clustering_distance_rows = "euclidean", clustering_distance_cols = "euclidean",legend = T,labels_row = heat_data$molecular_group,labels_col = filtered_df_RF$name.x,color =brewer.pal(n = 5, name = "RdPu") )

```

# ORA enrichmentr

```{r ORA with enrich-R}

# List available databases from Enrichr
#dbs <- listEnrichrDbs()
#dbs <- dbs[order(dbs$libraryName),]
#Databases <- data.frame(dbs$libraryName)

# Enrichment analysis for DrugMatrix and IDG_Drug_Targets_2022 databases

# Define the databases for enrichment analysis
#dbs_dd <- c("DrugMatrix")

dbs_bp<- c("GO_Biological_Process_2023","GO_Molecular_Function_2023","WikiPathway_2023_Human")

# Perform enrichment analysis GO
Fibrosis_GO <- enrichr(genes = (filtered_Fibrosis$name), databases = dbs_bp)

Inflammation_GO <- enrichr(genes = filtered_Inflammation$name, databases = dbs_bp)

# BP
plotEnrich(Fibrosis_GO[[1]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Fibrosis BP")
plotEnrich(Inflammation_GO[[1]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Inflammation BP")

# MF

plotEnrich(Fibrosis_GO[[2]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Fibrosis MF")
plotEnrich(Inflammation_GO[[2]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Inflammation MF")

# WP

plotEnrich(Fibrosis_GO[[3]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Fibrosis WK")
plotEnrich(Inflammation_GO[[3]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score", title = "ORA enrichment Inflammation WK")

# Perform enrichment analysis drugmatrix
#upClinical_Fibrosis <- enrichr(genes = filtered_Fibrosis$Gene.Symbol, databases = dbs_dd)

#upClinical_Inflammation <- enrichr(genes = filtered_Inflammation$Gene.Symbol, databases = dbs_dd)
#plotEnrich(upClinical_Fibrosis[[1]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score")
#plotEnrich(upClinical_Inflammation[[1]], showTerms = 20, numChar = 50, y = "Count", orderBy = "Combined.Score")
```

# GSEA with gprofiler

```{r GSEA }
# Load the gprofiler2 library
library(gprofiler2)

# Perform over-representation analysis using GOST (Gene Ontology Semantic Similarity)
# 'res_gost' will store the results of the analysis
res_gost <- gost(
  query = filtered_Inflammation$name,              # The list of gene symbols to analyze
  organism = "hsapiens",                  # The organism for the analysis (Homo sapiens)
  ordered_query = T,                      # If TRUE, the query is treated as an ordered list as a GSEA
  multi_query = FALSE,                    # If TRUE, allows multiple queries in a single run
  significant = TRUE,                     # If TRUE, only returns significant results
  exclude_iea = FALSE,                    # If TRUE, excludes electronically inferred annotations
  correction_method = "g_SCS", #"g_SCS", "bonferroni", "fdr"
  measure_underrepresentation = FALSE,    # If TRUE, measures underrepresentation of terms
  evcodes = FALSE,                        # If TRUE, includes evidence codes in the results
  user_threshold = 0.001,                   # Sets the significance threshold for the analysis
  custom_bg = NULL,                       # Allows specifying a custom background gene set
  numeric_ns = "",                        # Numeric namespace for the query
  sources = c("GO:BP", "GO:MF", "REAC", "WP","KEGG"),  # Data sources to use (GO: Biological Process, Molecular Function, Cellular Component)
  as_short_link = FALSE                   # If TRUE, returns a short link to the results
)

# Plot the results of the GOST analysis
# 'plot_gost' will store the plot object
plot_gost <- gostplot(
  res_gost,                               # The GOST results to plot
  capped = TRUE,                          # If TRUE, caps the number of displayed terms
  interactive = TRUE                      # If TRUE, creates an interactive plot
)

# Display the plot
plot_gost
data_GOST <- data.frame(res_gost[["result"]])
```

# SCUDO draft
```{r test SCUDO}
set.seed(1234)
bt <- as.factor(disease_state$molecular_group)

# Extract the right object 
exp_set <- gset2[["GSE15235_series_matrix.txt.gz"]]

inTrain <- caret::createDataPartition(bt, list = FALSE)
trainData <- exp_set[, inTrain]
testData <- exp_set[, -inTrain]

trainRes <- scudoTrain(trainData, groups = bt[inTrain], nTop = 500,
    nBottom = 500,alpha = 0.01,foldChange = T,featureSel = T)
trainRes

upSignatures(trainRes)[1:5,1:5]

Cons_UP_SCUDO <- consensusUpSignatures(trainRes)[1:20, ]

testNet <- scudoNetwork(trainRes,N = 0.33)
scudoPlot(testNet, vertex.label = NA)

```

```{r}
set.seed(1234)
testRes <- scudoTest(trainRes, testData, bt[-inTrain], nTop = 500,
    nBottom = 500)
testRes

testNet <- scudoNetwork(testRes, N = 0.33)
scudoPlot(testNet, vertex.label = NA)

testClust <- igraph::cluster_spinglass(testNet,spins = 15,parupdate = T)
plot(testClust, testNet, vertex.label = NA)
```

```{r}
set.seed(1234)
classRes <- scudoClassify(trainData, testData, N = 0.33, nTop = 200,
    nBottom = 200, trainGroups = bt[inTrain], alpha = 0.1)

classRes$predicted

caret::confusionMatrix(classRes$predicted, bt[-inTrain])

rm(classRes)
```

